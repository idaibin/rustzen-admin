# Rustzen Project Philosophy & Conventions

## ğŸŒ¿ The Rustzen Philosophy

**Rustzen** = **Rust** + **Zen**

Core principles:

-   **ç®€çº¦è€Œä¸ç®€å•** (Simple but not simplistic)
-   **å¤§é“è‡³ç®€** (The great way is simple)
-   **æ¯ä¸€å±‚éƒ½èƒ½è‡ªåœ†å…¶è¯´** (Every layer should justify its existence)
-   **AI å‹å¥½** (AI-friendly architecture)

## ğŸ¯ Project Conventions

### 1. Dependency Management

-   **Never modify `Cargo.toml` directly**
-   Always use `cargo add <package>` for new dependencies
-   Get user confirmation before adding new dependencies
-   Keep dependencies minimal and purposeful

### 2. Version Control & Commits

-   **Commit messages must be in English**
-   Use conventional commit format when possible
-   Update `CHANGELOG.md` when version changes
-   Keep commits atomic and focused

### 3. API Response Format

-   **All API responses use camelCase** for field names
-   Use `#[serde(rename_all = "camelCase")]` on response structs
-   Maintain consistent response structure:

```json
{
  "code": 0,
  "message": "success",
  "data": { ... }
}
```

### 4. Error Handling Philosophy

-   **Handle all exceptions at the first exception site**
-   Never let database errors bubble up raw
-   Convert errors immediately where they occur:
    -   `sqlx::Error` â†’ `ServiceError` in **repo layer** (at error source)
    -   `ServiceError` â†’ `AppError` in routes layer (automatic conversion)
-   Use `Result<T, E>` consistently, avoid `unwrap()` in business code
-   Always log errors with context at the conversion site

### 5. Permission & Authentication

-   Permission checks at service entry points
-   Use declarative permission checking (e.g., `auth.check_permission("user:list")`)
-   JWT-based authentication with middleware
-   Context injection through extractors

## ğŸ—ï¸ Architecture Principles

### Extreme Simplification

-   Eliminate unnecessary layers (handler, usecase, domain for CRUD)
-   Keep only essential abstractions
-   Prefer composition over inheritance
-   Each module should have clear, single responsibility

### AI-Friendly Design

-   Clear, predictable file structures
-   Consistent naming conventions
-   Minimal cognitive load for automated tools
-   Self-documenting code organization

### Maintainability First

-   Code should be easy to read and modify
-   Clear separation of concerns
-   Minimal coupling between modules
-   Easy to test and debug

## ğŸ“ File Organization Standards

### Naming Conventions

-   Files: `snake_case` (e.g., `user_service.rs`)
-   Structs/Enums: `PascalCase` (e.g., `UserResponse`)
-   Functions/Variables: `snake_case` (e.g., `get_user_list`)
-   Database tables: `snake_case` (e.g., `sys_user`)

### Module Structure

Each feature module contains:

```
module/
â”œâ”€â”€ mod.rs          // Module declarations
â”œâ”€â”€ router.rs       // HTTP routing and handlers
â”œâ”€â”€ service.rs      // Business logic
â”œâ”€â”€ repo.rs         // Database operations
â”œâ”€â”€ entity.rs       // Database entities
â”œâ”€â”€ dto.rs          // Data transfer objects
â””â”€â”€ vo.rs           // View objects (API responses)
```

**Example: System Management Module Structure**

```
features/
â”œâ”€â”€ auth/           // Authentication module
â””â”€â”€ system/         // System management module
    â”œâ”€â”€ mod.rs      // System module declarations
    â”œâ”€â”€ user/       // User management submodule
    â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”œâ”€â”€ router.rs
    â”‚   â”œâ”€â”€ service.rs
    â”‚   â”œâ”€â”€ repo.rs
    â”‚   â”œâ”€â”€ entity.rs
    â”‚   â”œâ”€â”€ dto.rs
    â”‚   â””â”€â”€ vo.rs
    â”œâ”€â”€ role/       // Role management submodule
    â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”œâ”€â”€ router.rs
    â”‚   â”œâ”€â”€ service.rs
    â”‚   â”œâ”€â”€ repo.rs
    â”‚   â”œâ”€â”€ entity.rs
    â”‚   â”œâ”€â”€ dto.rs
    â”‚   â””â”€â”€ vo.rs
    â””â”€â”€ menu/       // Menu management submodule
        â”œâ”€â”€ mod.rs
        â”œâ”€â”€ router.rs
        â”œâ”€â”€ service.rs
        â”œâ”€â”€ repo.rs
        â”œâ”€â”€ entity.rs
        â”œâ”€â”€ dto.rs
        â””â”€â”€ vo.rs
```

### Import Organization

```rust
// Standard library
use std::collections::HashMap;

// External crates
use axum::{Router, Json};
use sqlx::PgPool;

// Internal modules
use crate::common::{AppError, ApiResponse};
use crate::core::auth::AuthContext;

// Local modules
use super::entity::UserEntity;
```

## ğŸ”§ Development Workflow

### Before Making Changes

1. Understand the existing architecture
2. Follow the three-layer principle (routes â†’ service â†’ repo)
3. Check existing patterns and conventions
4. Consider AI assistance for repetitive tasks

### Code Quality Standards

-   Use `clippy` for linting
-   Format with `rustfmt`
-   Write tests for business logic
-   Document complex functions
-   Use `tracing` for logging, not `println!`

### Database Changes

-   Follow Zen migration numbering system
-   One entity per migration file
-   Test migrations both ways (up and down)
-   Document complex schema changes

## ğŸ¤– AI Collaboration Guidelines

### Leverage AI For

-   Code generation following established patterns
-   Bulk refactoring across modules
-   Migration file generation
-   Documentation updates
-   Test case generation

### Maintain Human Oversight For

-   Architecture decisions
-   Business logic validation
-   Security considerations
-   Performance optimizations
-   Database schema design

## ğŸš€ Future Evolution

### Planned Extensions

-   Docker containerization
-   Advanced RBAC system
-   API documentation automation
-   Performance monitoring
-   Logging and observability

### Principles for Growth

-   Maintain simplicity as complexity increases
-   Add layers only when absolutely necessary
-   Keep the core philosophy intact
-   Ensure new features follow established patterns

## ğŸ’­ Zen Thinking in Practice

When facing a decision, ask:

1. **Does this add genuine value?**
2. **Can this be simpler?**
3. **Will this be clear to others (including AI)?**
4. **Does this follow our established patterns?**
5. **Is this the minimal solution that works?**

Remember: **The best code is code that doesn't need to exist, but when it must exist, it should be crystal clear why.**
description:
globs:
alwaysApply: false

---
